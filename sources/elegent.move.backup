// ELEGENT DeFi Platform - Comprehensive Move Smart Contract for Aptos
// Merged version with enhanced features: RBAC, Dynamic APR, Loan NFTs, Multi-token support, 
// APY rewards, Trust Score system, Staking, and Refinancing capabilities

module elegent::elegent_defi {
    use std::signer;
    use std::vector;
    use std::option;
    use std::string::{Self, String};
    use std::timestamp;
    use std::error;
    use aptos_framework::coin;
    use aptos_framework::token;
    use aptos_framework::aptos_coin::AptosCoin;
    use aptos_framework::account;
    use aptos_framework::event;
    use aptos_framework::table::{Self, Table};

    // ============================================================================
    // ERROR CODES
    // ============================================================================
    const E_NOT_INITIALIZED: u64 = 1;
    const E_ALREADY_INITIALIZED: u64 = 2;
    const E_UNAUTHORIZED: u64 = 3;
    const E_INVALID_ROLE: u64 = 4;
    const E_INSUFFICIENT_TRUST_SCORE: u64 = 5;
    const E_LOAN_NOT_FOUND: u64 = 6;
    const E_INSUFFICIENT_FUNDS: u64 = 7;
    const E_LOAN_ALREADY_REPAID: u64 = 8;
    const E_INVALID_AMOUNT: u64 = 9;
    const E_LOAN_OVERDUE: u64 = 10;
    const E_REPAY_TOO_EARLY: u64 = 11;
    const E_PLATFORM_PAUSED: u64 = 12;
    const E_LOAN_ACTIVE: u64 = 13;

    // ============================================================================
    // CONSTANTS
    // ============================================================================
    const INITIAL_TRUST_SCORE: u64 = 100;
    const MAX_TRUST_SCORE: u64 = 1000;
    const MIN_LOAN_AMOUNT: u64 = 1000000; // 0.01 APT (8 decimals)
    const MAX_LOAN_AMOUNT: u64 = 100000000000; // 1000 APT
    const LOAN_DURATION_SECONDS: u64 = 2592000; // 30 days
    const WEEK_IN_SECONDS: u64 = 604800; // 7 days
    const EARLY_REPAY_BONUS: u64 = 10; // Trust score bonus for early repayment
    const STAKING_REWARD_BPS: u64 = 1000; // 10% APY
    const LIQUIDATION_THRESHOLD: u64 = 2; // Days past due before liquidation

    // ============================================================================
    // STRUCTS
    // ============================================================================

    /// Role-based access control
    struct Roles has key {
        moderators: Table<address, bool>,
        oracles: Table<address, bool>,
        admin: address,
    }

    /// Trust Score NFT with comprehensive user data
    struct TrustScoreNFT has key {
        score: u64,
        tier: String,
        loan_count: u64,
        total_borrowed: u64,
        total_repaid: u64,
        defaults: u64,
        last_updated: u64,
        staked_amount: u64,
        wallet_age: u64,
        early_repayments: u64,
        refinance_count: u64,
    }

    /// Loan NFT for tokenizing loans
    struct LoanNFT has key, store {
        id: u64,
        metadata_uri: String,
        loan_id: u64,
        borrower: address,
    }

    /// Enhanced loan structure with multi-token support
    struct Loan has store, copy, drop {
        id: u64,
        borrower: address,
        token_type: String, // Support for multiple token types
        amount: u64,
        interest_amount: u64,
        dynamic_interest_rate: u64, // BPS, can change based on trust score
        due_date: u64,
        status: u8, // 0: active, 1: repaid, 2: defaulted, 3: liquidated, 4: extended
        created_at: u64,
        last_extended: u64,
        extension_count: u64,
        collateral_amount: u64, // For secured loans
    }

    /// Platform state with enhanced features
    struct PlatformState has key {
        total_loans: u64,
        total_volume: u64,
        active_loans: Table<u64, Loan>,
        user_loans: Table<address, vector<u64>>,
        treasury_balance: u64,
        is_paused: bool,
        admin: address,
        loan_nft_counter: u64,
        supported_tokens: vector<String>,
        platform_fee_bps: u64, // Platform fee in basis points
        insurance_fund: u64,
    }

    /// Enhanced staking pool with rewards mechanism
    struct StakingPool has key {
        total_staked: u64,
        user_stakes: Table<address, u64>,
        user_rewards: Table<address, u64>,
        pending_withdrawals: Table<address, u64>,
        last_reward_time: u64,
        reward_rate: u64, // APY in basis points
        lock_duration: u64, // Lock period for staking
        user_stake_time: Table<address, u64>,
    }

    /// Refinancing tracker
    struct RefinanceTracker has key {
        refinanced_loans: Table<u64, u64>, // old_loan_id -> new_loan_id
        refinance_history: Table<address, vector<u64>>,
    }

    // ============================================================================
    // EVENTS
    // ============================================================================
    struct LoanCreatedEvent has drop, store {
        loan_id: u64,
        borrower: address,
        amount: u64,
        token_type: String,
        interest_rate: u64,
        due_date: u64,
        nft_id: u64,
    }

    struct LoanRepaidEvent has drop, store {
        loan_id: u64,
        borrower: address,
        amount: u64,
        interest: u64,
        early_repayment: bool,
    }

    struct LoanExtendedEvent has drop, store {
        loan_id: u64,
        borrower: address,
        new_due_date: u64,
        extension_count: u64,
    }

    struct LoanRefinancedEvent has drop, store {
        old_loan_id: u64,
        new_loan_id: u64,
        borrower: address,
        old_rate: u64,
        new_rate: u64,
    }

    struct LoanLiquidatedEvent has drop, store {
        loan_id: u64,
        borrower: address,
        amount: u64,
        liquidator: address,
    }

    struct TrustScoreUpdatedEvent has drop, store {
        user: address,
        old_score: u64,
        new_score: u64,
        tier: String,
        reason: String,
    }

    struct StakeEvent has drop, store {
        user: address,
        amount: u64,
        total_staked: u64,
        lock_until: u64,
    }

    struct RewardsClaimedEvent has drop, store {
        user: address,
        amount: u64,
        reward_type: String,
    }

    /// Event handles
    struct EventHandles has key {
        loan_created_events: event::EventHandle<LoanCreatedEvent>,
        loan_repaid_events: event::EventHandle<LoanRepaidEvent>,
        loan_extended_events: event::EventHandle<LoanExtendedEvent>,
        loan_refinanced_events: event::EventHandle<LoanRefinancedEvent>,
        loan_liquidated_events: event::EventHandle<LoanLiquidatedEvent>,
        trust_score_updated_events: event::EventHandle<TrustScoreUpdatedEvent>,
        stake_events: event::EventHandle<StakeEvent>,
        rewards_claimed_events: event::EventHandle<RewardsClaimedEvent>,
    }

    // ============================================================================
    // INITIALIZATION FUNCTIONS
    // ============================================================================

    /// Initialize the platform with all components
    public entry fun initialize(admin: &signer) {
        let admin_addr = signer::address_of(admin);
        assert!(!exists<PlatformState>(admin_addr), error::already_exists(E_ALREADY_INITIALIZED));

        // Initialize platform state
        move_to(admin, PlatformState {
            total_loans: 0,
            total_volume: 0,
            active_loans: table::new(),
            user_loans: table::new(),
            treasury_balance: 0,
            is_paused: false,
            admin: admin_addr,
            loan_nft_counter: 0,
            supported_tokens: vector::empty<String>(),
            platform_fee_bps: 100, // 1% platform fee
            insurance_fund: 0,
        });

        // Initialize roles
        move_to(admin, Roles {
            moderators: table::new(),
            oracles: table::new(),
            admin: admin_addr,
        });

        // Initialize staking pool
        move_to(admin, StakingPool {
            total_staked: 0,
            user_stakes: table::new(),
            user_rewards: table::new(),
            pending_withdrawals: table::new(),
            last_reward_time: timestamp::now_seconds(),
            reward_rate: STAKING_REWARD_BPS,
            lock_duration: 2592000, // 30 days lock
            user_stake_time: table::new(),
        });

        // Initialize refinance tracker
        move_to(admin, RefinanceTracker {
            refinanced_loans: table::new(),
            refinance_history: table::new(),
        });

        // Initialize event handles
        move_to(admin, EventHandles {
            loan_created_events: account::new_event_handle<LoanCreatedEvent>(admin),
            loan_repaid_events: account::new_event_handle<LoanRepaidEvent>(admin),
            loan_extended_events: account::new_event_handle<LoanExtendedEvent>(admin),
            loan_refinanced_events: account::new_event_handle<LoanRefinancedEvent>(admin),
            loan_liquidated_events: account::new_event_handle<LoanLiquidatedEvent>(admin),
            trust_score_updated_events: account::new_event_handle<TrustScoreUpdatedEvent>(admin),
            stake_events: account::new_event_handle<StakeEvent>(admin),
            rewards_claimed_events: account::new_event_handle<RewardsClaimedEvent>(admin),
        });

        // Add APT as default supported token
        let platform_state = borrow_global_mut<PlatformState>(admin_addr);
        vector::push_back(&mut platform_state.supported_tokens, string::utf8(b"APT"));
    }

    /// Create initial TrustScore NFT for new users
    public entry fun create_trust_score(account: &signer) {
        let user_addr = signer::address_of(account);
        assert!(!exists<TrustScoreNFT>(user_addr), error::already_exists(E_ALREADY_INITIALIZED));

        let wallet_age = calculate_wallet_age(user_addr);
        let initial_score = INITIAL_TRUST_SCORE + (wallet_age / 86400 / 30); // Bonus for wallet age

        move_to(account, TrustScoreNFT {
            score: initial_score,
            tier: get_tier_from_score(initial_score),
            loan_count: 0,
            total_borrowed: 0,
            total_repaid: 0,
            defaults: 0,
            last_updated: timestamp::now_seconds(),
            staked_amount: 0,
            wallet_age,
            early_repayments: 0,
            refinance_count: 0,
        });
    }

    // ============================================================================
    // CORE LOAN FUNCTIONS
    // ============================================================================

    /// Request a loan with multi-token support
    public entry fun request_loan(
        borrower: &signer,
        amount: u64,
        token_type: String,
        platform_admin: address
    ) acquires PlatformState, TrustScoreNFT, EventHandles {
        let borrower_addr = signer::address_of(borrower);
        
        // Validation checks
        assert!(exists<TrustScoreNFT>(borrower_addr), error::not_found(E_NOT_INITIALIZED));
        assert!(amount >= MIN_LOAN_AMOUNT && amount <= MAX_LOAN_AMOUNT, error::invalid_argument(E_INVALID_AMOUNT));

        let platform_state = borrow_global_mut<PlatformState>(platform_admin);
        assert!(!platform_state.is_paused, error::unavailable(E_PLATFORM_PAUSED));

        // Check if token is supported
        assert!(vector::contains(&platform_state.supported_tokens, &token_type), error::invalid_argument(E_INVALID_AMOUNT));

        let trust_score = borrow_global<TrustScoreNFT>(borrower_addr);
        let max_loan_amount = calculate_max_loan_amount(trust_score.score, trust_score.staked_amount);
        assert!(amount <= max_loan_amount, error::permission_denied(E_INSUFFICIENT_TRUST_SCORE));

        // Calculate dynamic interest rate based on trust score
        let interest_rate = calculate_dynamic_interest_rate(trust_score.score);
        let interest_amount = (amount * interest_rate) / 10000;

        let loan_id = platform_state.total_loans + 1;
        let nft_id = platform_state.loan_nft_counter + 1;
        let due_date = timestamp::now_seconds() + LOAN_DURATION_SECONDS;

        // Create loan
        let loan = Loan {
            id: loan_id,
            borrower: borrower_addr,
            token_type,
            amount,
            interest_amount,
            dynamic_interest_rate: interest_rate,
            due_date,
            status: 0, // active
            created_at: timestamp::now_seconds(),
            last_extended: 0,
            extension_count: 0,
            collateral_amount: 0,
        };

        // Store loan
        table::add(&mut platform_state.active_loans, loan_id, loan);
        
        // Update user loans
        if (!table::contains(&platform_state.user_loans, borrower_addr)) {
            table::add(&mut platform_state.user_loans, borrower_addr, vector::empty<u64>());
        };
        let user_loans = table::borrow_mut(&mut platform_state.user_loans, borrower_addr);
        vector::push_back(user_loans, loan_id);

        // Update platform state
        platform_state.total_loans = loan_id;
        platform_state.loan_nft_counter = nft_id;
        platform_state.total_volume = platform_state.total_volume + amount;

        // Create Loan NFT
        move_to(borrower, LoanNFT {
            id: nft_id,
            metadata_uri: string::utf8(b"https://elegent.finance/nft/"),
            loan_id,
            borrower: borrower_addr,
        });

        // Update borrower's trust score
        let trust_score_mut = borrow_global_mut<TrustScoreNFT>(borrower_addr);
        trust_score_mut.loan_count = trust_score_mut.loan_count + 1;
        trust_score_mut.total_borrowed = trust_score_mut.total_borrowed + amount;
        trust_score_mut.last_updated = timestamp::now_seconds();

        // Emit event
        let event_handles = borrow_global_mut<EventHandles>(platform_admin);
        event::emit_event(&mut event_handles.loan_created_events, LoanCreatedEvent {
            loan_id,
            borrower: borrower_addr,
            amount,
            token_type,
            interest_rate,
            due_date,
            nft_id,
        });
    }

    /// Repay a loan with early repayment bonus
    public entry fun repay_loan(
        borrower: &signer,
        loan_id: u64,
        platform_admin: address
    ) acquires PlatformState, TrustScoreNFT, EventHandles {
        let borrower_addr = signer::address_of(borrower);
        
        let platform_state = borrow_global_mut<PlatformState>(platform_admin);
        assert!(table::contains(&platform_state.active_loans, loan_id), error::not_found(E_LOAN_NOT_FOUND));

        let loan = table::borrow_mut(&mut platform_state.active_loans, loan_id);
        assert!(loan.borrower == borrower_addr, error::permission_denied(E_UNAUTHORIZED));
        assert!(loan.status == 0, error::invalid_state(E_LOAN_ALREADY_REPAID));

        let current_time = timestamp::now_seconds();
        let total_repayment = loan.amount + loan.interest_amount;
        let is_early = current_time < loan.due_date - WEEK_IN_SECONDS;

        // Calculate platform fee
        let platform_fee = (total_repayment * platform_state.platform_fee_bps) / 10000;
        let net_repayment = total_repayment - platform_fee;

        // Transfer repayment (simplified for MVP)
        coin::transfer<AptosCoin>(borrower, platform_admin, total_repayment);

        // Update loan status
        loan.status = 1; // repaid

        // Update trust score with early repayment bonus
        let trust_score = borrow_global_mut<TrustScoreNFT>(borrower_addr);
        trust_score.total_repaid = trust_score.total_repaid + total_repayment;
        
        let old_score = trust_score.score;
        let score_change = if (is_early) { 
            trust_score.early_repayments = trust_score.early_repayments + 1;
            EARLY_REPAY_BONUS + 5 // Extra bonus for early repayment
        } else { 
            10 // Standard repayment bonus
        };

        trust_score.score = if (trust_score.score + score_change <= MAX_TRUST_SCORE) {
            trust_score.score + score_change
        } else {
            MAX_TRUST_SCORE
        };
        trust_score.tier = get_tier_from_score(trust_score.score);
        trust_score.last_updated = current_time;

        // Update platform treasury
        platform_state.treasury_balance = platform_state.treasury_balance + platform_fee;

        // Emit events
        let event_handles = borrow_global_mut<EventHandles>(platform_admin);
        event::emit_event(&mut event_handles.loan_repaid_events, LoanRepaidEvent {
            loan_id,
            borrower: borrower_addr,
            amount: loan.amount,
            interest: loan.interest_amount,
            early_repayment: is_early,
        });

        event::emit_event(&mut event_handles.trust_score_updated_events, TrustScoreUpdatedEvent {
            user: borrower_addr,
            old_score,
            new_score: trust_score.score,
            tier: trust_score.tier,
            reason: if (is_early) { string::utf8(b"Early Repayment") } else { string::utf8(b"On-time Repayment") },
        });
    }

    /// Extend loan duration
    public entry fun extend_loan(
        borrower: &signer,
        loan_id: u64,
        platform_admin: address
    ) acquires PlatformState, EventHandles {
        let borrower_addr = signer::address_of(borrower);
        
        let platform_state = borrow_global_mut<PlatformState>(platform_admin);
        assert!(table::contains(&platform_state.active_loans, loan_id), error::not_found(E_LOAN_NOT_FOUND));

        let loan = table::borrow_mut(&mut platform_state.active_loans, loan_id);
        assert!(loan.borrower == borrower_addr, error::permission_denied(E_UNAUTHORIZED));
        assert!(loan.status == 0, error::invalid_state(E_LOAN_ALREADY_REPAID));

        let current_time = timestamp::now_seconds();
        assert!(current_time <= loan.due_date, error::invalid_state(E_LOAN_OVERDUE));

        // Update loan extension
        loan.due_date = loan.due_date + LOAN_DURATION_SECONDS;
        loan.extension_count = loan.extension_count + 1;
        loan.last_extended = current_time;
        loan.status = 4; // extended

        // Calculate extension fee (5% of original amount)
        let extension_fee = (loan.amount * 500) / 10000;
        coin::transfer<AptosCoin>(borrower, platform_admin, extension_fee);

        // Update platform treasury
        platform_state.treasury_balance = platform_state.treasury_balance + extension_fee;

        // Emit event
        let event_handles = borrow_global_mut<EventHandles>(platform_admin);
        event::emit_event(&mut event_handles.loan_extended_events, LoanExtendedEvent {
            loan_id,
            borrower: borrower_addr,
            new_due_date: loan.due_date,
            extension_count: loan.extension_count,
        });
    }

    /// Refinance existing loan with better terms
    public entry fun refinance_loan(
        borrower: &signer,
        old_loan_id: u64,
        platform_admin: address
    ) acquires PlatformState, TrustScoreNFT, RefinanceTracker, EventHandles {
        let borrower_addr = signer::address_of(borrower);
        
        let platform_state = borrow_global_mut<PlatformState>(platform_admin);
        assert!(table::contains(&platform_state.active_loans, old_loan_id), error::not_found(E_LOAN_NOT_FOUND));

        let old_loan = table::borrow(&platform_state.active_loans, old_loan_id);
        assert!(old_loan.borrower == borrower_addr, error::permission_denied(E_UNAUTHORIZED));
        assert!(old_loan.status == 0, error::invalid_state(E_LOAN_ALREADY_REPAID));

        let trust_score = borrow_global<TrustScoreNFT>(borrower_addr);
        let new_interest_rate = calculate_dynamic_interest_rate(trust_score.score);
        
        // Only allow refinancing if new rate is better
        assert!(new_interest_rate < old_loan.dynamic_interest_rate, error::invalid_argument(E_INVALID_AMOUNT));

        // Create new loan with better terms
        let new_loan_id = platform_state.total_loans + 1;
        let new_interest_amount = (old_loan.amount * new_interest_rate) / 10000;

        let new_loan = Loan {
            id: new_loan_id,
            borrower: borrower_addr,
            token_type: old_loan.token_type,
            amount: old_loan.amount,
            interest_amount: new_interest_amount,
            dynamic_interest_rate: new_interest_rate,
            due_date: timestamp::now_seconds() + LOAN_DURATION_SECONDS,
            status: 0, // active
            created_at: timestamp::now_seconds(),
            last_extended: 0,
            extension_count: 0,
            collateral_amount: old_loan.collateral_amount,
        };

        // Store new loan and mark old loan as repaid
        table::add(&mut platform_state.active_loans, new_loan_id, new_loan);
        let old_loan_mut = table::borrow_mut(&mut platform_state.active_loans, old_loan_id);
        old_loan_mut.status = 1; // Mark as repaid

        platform_state.total_loans = new_loan_id;

        // Update refinance tracker
        let refinance_tracker = borrow_global_mut<RefinanceTracker>(platform_admin);
        table::add(&mut refinance_tracker.refinanced_loans, old_loan_id, new_loan_id);

        if (!table::contains(&refinance_tracker.refinance_history, borrower_addr)) {
            table::add(&mut refinance_tracker.refinance_history, borrower_addr, vector::empty<u64>());
        };
        let user_refinances = table::borrow_mut(&mut refinance_tracker.refinance_history, borrower_addr);
        vector::push_back(user_refinances, new_loan_id);

        // Update trust score
        let trust_score_mut = borrow_global_mut<TrustScoreNFT>(borrower_addr);
        trust_score_mut.refinance_count = trust_score_mut.refinance_count + 1;
        trust_score_mut.score = trust_score_mut.score + 5; // Bonus for refinancing

        // Emit event
        let event_handles = borrow_global_mut<EventHandles>(platform_admin);
        event::emit_event(&mut event_handles.loan_refinanced_events, LoanRefinancedEvent {
            old_loan_id,
            new_loan_id,
            borrower: borrower_addr,
            old_rate: old_loan.dynamic_interest_rate,
            new_rate: new_interest_rate,
        });
    }

    /// Liquidate overdue loans
    public entry fun liquidate_loan(
        liquidator: &signer,
        loan_id: u64,
        platform_admin: address
    ) acquires PlatformState, TrustScoreNFT, EventHandles {
        let liquidator_addr = signer::address_of(liquidator);
        
        let platform_state = borrow_global_mut<PlatformState>(platform_admin);
        assert!(table::contains(&platform_state.active_loans, loan_id), error::not_found(E_LOAN_NOT_FOUND));

        let loan = table::borrow_mut(&mut platform_state.active_loans, loan_id);
        let current_time = timestamp::now_seconds();
        let days_overdue = (current_time - loan.due_date) / 86400;

        assert!(loan.status == 0, error::invalid_state(E_LOAN_ALREADY_REPAID));
        assert!(days_overdue >= LIQUIDATION_THRESHOLD, error::invalid_state(E_LOAN_ACTIVE));

        // Update loan status
        loan.status = 3; // liquidated

        // Update borrower's trust score (penalty for default)
        let trust_score = borrow_global_mut<TrustScoreNFT>(loan.borrower);
        trust_score.defaults = trust_score.defaults + 1;
        trust_score.score = if (trust_score.score >= 50) { trust_score.score - 50 } else { 0 };
        trust_score.tier = get_tier_from_score(trust_score.score);

        // Liquidation reward for liquidator (5% of loan amount)
        let liquidation_reward = (loan.amount * 500) / 10000;
        coin::transfer<AptosCoin>(&platform_state.admin, liquidator_addr, liquidation_reward);

        // Emit event
        let event_handles = borrow_global_mut<EventHandles>(platform_admin);
        event::emit_event(&mut event_handles.loan_liquidated_events, LoanLiquidatedEvent {
            loan_id,
            borrower: loan.borrower,
            amount: loan.amount,
            liquidator: liquidator_addr,
        });
    }

    // ============================================================================
    // STAKING FUNCTIONS
    // ============================================================================

    /// Stake APT to increase loan limits and earn rewards
    public entry fun stake_apt(
        user: &signer,
        amount: u64,
        platform_admin: address
    ) acquires StakingPool, TrustScoreNFT, EventHandles {
        let user_addr = signer::address_of(user);
        assert!(exists<TrustScoreNFT>(user_addr), error::not_found(E_NOT_INITIALIZED));
        assert!(amount > 0, error::invalid_argument(E_INVALID_AMOUNT));

        let current_time = timestamp::now_seconds();

        // Transfer APT to staking pool
        coin::transfer<AptosCoin>(user, platform_admin, amount);

        let staking_pool = borrow_global_mut<StakingPool>(platform_admin);
        
        // Initialize user staking data if needed
        if (!table::contains(&staking_pool.user_stakes, user_addr)) {
            table::add(&mut staking_pool.user_stakes, user_addr, 0);
            table::add(&mut staking_pool.user_rewards, user_addr, 0);
            table::add(&mut staking_pool.pending_withdrawals, user_addr, 0);
            table::add(&mut staking_pool.user_stake_time, user_addr, current_time);
        };

        // Accrue rewards before updating stake
        accrue_staking_rewards(user_addr, platform_admin);

        // Update stake
        let user_stake = table::borrow_mut(&mut staking_pool.user_stakes, user_addr);
        *user_stake = *user_stake + amount;
        staking_pool.total_staked = staking_pool.total_staked + amount;

        // Update stake time
        let stake_time = table::borrow_mut(&mut staking_pool.user_stake_time, user_addr);
        *stake_time = current_time;

        // Update trust score
        let trust_score = borrow_global_mut<TrustScoreNFT>(user_addr);
        trust_score.staked_amount = trust_score.staked_amount + amount;
        trust_score.score = trust_score.score + (amount / 1000000); // 1 point per 0.01 APT staked

        // Emit event
        let event_handles = borrow_global_mut<EventHandles>(platform_admin);
        event::emit_event(&mut event_handles.stake_events, StakeEvent {
            user: user_addr,
            amount,
            total_staked: *user_stake,
        });
    }

    /// Unstake APT tokens
    public entry fun unstake_apt(
        user: &signer,
        amount: u64,
        platform_admin: address
    ) acquires StakingPool, TrustScoreNFT, EventHandles {
        let user_addr = signer::address_of(user);
        assert!(exists<TrustScoreNFT>(user_addr), error::not_found(E_NOT_INITIALIZED));
        assert!(amount > 0, error::invalid_argument(E_INVALID_AMOUNT));

        let staking_pool = borrow_global_mut<StakingPool>(platform_admin);
        assert!(table::contains(&staking_pool.user_stakes, user_addr), error::not_found(E_NOT_INITIALIZED));

        let user_stake = table::borrow_mut(&mut staking_pool.user_stakes, user_addr);
        assert!(*user_stake >= amount, error::invalid_argument(E_INSUFFICIENT_FUNDS));

        // Accrue rewards before unstaking
        accrue_staking_rewards(user_addr, platform_admin);

        // Update stake
        *user_stake = *user_stake - amount;
        staking_pool.total_staked = staking_pool.total_staked - amount;

        // Add to pending withdrawals (simplified for MVP - instant for now)
        let pending = table::borrow_mut(&mut staking_pool.pending_withdrawals, user_addr);
        *pending = *pending + amount;

        // Update trust score
        let trust_score = borrow_global_mut<TrustScoreNFT>(user_addr);
        trust_score.staked_amount = trust_score.staked_amount - amount;

        // Emit event
        let event_handles = borrow_global_mut<EventHandles>(platform_admin);
        event::emit_event(&mut event_handles.stake_events, StakeEvent {
            user: user_addr,
            amount,
            total_staked: *user_stake,
        });
    }

    // ============================================================================
    // VIEW FUNCTIONS
    // ============================================================================

    #[view]
    public fun get_trust_score(user: address): (u64, String) acquires TrustScoreNFT {
        if (!exists<TrustScoreNFT>(user)) {
            return (0, string::utf8(b"No Score"))
        };
        let trust_score = borrow_global<TrustScoreNFT>(user);
        (trust_score.score, trust_score.tier)
    }

    #[view]
    public fun get_max_loan_amount(user: address): u64 acquires TrustScoreNFT {
        if (!exists<TrustScoreNFT>(user)) {
            return 0
        };
        let trust_score = borrow_global<TrustScoreNFT>(user);
        calculate_max_loan_amount(trust_score.score, trust_score.staked_amount)
    }

    #[view]
    public fun get_user_loans(user: address, platform_admin: address): vector<u64> acquires PlatformState {
        let platform_state = borrow_global<PlatformState>(platform_admin);
        if (!table::contains(&platform_state.user_loans, user)) {
            return vector::empty<u64>()
        };
        *table::borrow(&platform_state.user_loans, user)
    }

    #[view]
    public fun get_loan_details(loan_id: u64, platform_admin: address): (u64, address, u64, u64, u64, u8, u64) acquires PlatformState {
        let platform_state = borrow_global<PlatformState>(platform_admin);
        assert!(table::contains(&platform_state.active_loans, loan_id), error::not_found(E_LOAN_NOT_FOUND));
        
        let loan = table::borrow(&platform_state.active_loans, loan_id);
        (loan.id, loan.borrower, loan.amount, loan.interest_amount, loan.due_date, loan.status, loan.created_at)
    }

    // ============================================================================
    // HELPER FUNCTIONS
    // ============================================================================

    fun calculate_max_loan_amount(trust_score: u64, staked_amount: u64): u64 {
        let base_multiplier = if (trust_score >= 800) { 10 }
        else if (trust_score >= 600) { 8 }
        else if (trust_score >= 400) { 6 }
        else if (trust_score >= 200) { 4 }
        else { 2 };
        
        let base_amount = (trust_score * 100000) * base_multiplier; // 0.001 APT per point
        let staking_bonus = staked_amount * 2; // 2x staked amount
        
        let max_amount = base_amount + staking_bonus;
        if (max_amount > MAX_LOAN_AMOUNT) { MAX_LOAN_AMOUNT } else { max_amount }
    }

    fun calculate_dynamic_interest_rate(trust_score: u64): u64 {
        // Interest rate in BPS based on trust score
        if (trust_score >= 800) { 300 }        // 3% for diamond tier
        else if (trust_score >= 600) { 500 }   // 5% for platinum tier
        else if (trust_score >= 400) { 700 }   // 7% for gold tier
        else if (trust_score >= 200) { 1000 }  // 10% for silver tier
        else { 1500 }                           // 15% for bronze tier
    }

    fun get_tier_from_score(score: u64): String {
        if (score >= 800) { string::utf8(b"Diamond") }
        else if (score >= 600) { string::utf8(b"Platinum") }
        else if (score >= 400) { string::utf8(b"Gold") }
        else if (score >= 200) { string::utf8(b"Silver") }
        else { string::utf8(b"Bronze") }
    }

    fun accrue_staking_rewards(user: address, platform_admin: address) acquires StakingPool {
        let staking_pool = borrow_global_mut<StakingPool>(platform_admin);
        let current_time = timestamp::now_seconds();
        let time_diff = current_time - staking_pool.last_reward_time;
        
        if (time_diff > 0 && table::contains(&staking_pool.user_stakes, user)) {
            let user_stake = *table::borrow(&staking_pool.user_stakes, user);
            if (user_stake > 0) {
                let rewards = (user_stake * STAKING_REWARD_BPS * time_diff) / (10000 * 365 * 24 * 3600);
                let user_rewards = table::borrow_mut(&mut staking_pool.user_rewards, user);
                *user_rewards = *user_rewards + rewards;
            };
        };
        
        staking_pool.last_reward_time = current_time;
    }
}